{
    "Two Sum": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n = len(nums)\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        return []  # No solution found\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        pair_idx = {}\n\n        for i, num in enumerate(nums):\n            if target - num in pair_idx:\n                return [i, pair_idx[target - num]]\n            pair_idx[num] = i"
            },
            {
                "language": "Python",
                "code": [
                    "class Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        h = {}\n        for i, num in enumerate(nums):\n            n = target - num\n            if n not in h:\n                h[num] = i\n            else:\n                return [h[n], i]"
                ]
            }
        ],
        "source": "https://leetcode.com/problems/two-sum/"
    },
    "Palindrome Number": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n\n        reversed_num = 0\n        temp = x\n\n        while temp != 0:\n            digit = temp % 10\n            reversed_num = reversed_num * 10 + digit\n            temp //= 10\n\n        return reversed_num == x\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isPalindrome(self, x: int) -> bool:\n        if x < 0:\n            return False\n\n        reverse = 0\n        xcopy = x\n\n        while x > 0:\n            reverse = (reverse * 10) + (x % 10)\n            x //= 10\n        \n        return reverse == xcopy"
            },
            {
                "language": "Python",
                "code": ""
            }
        ],
        "source": "https://leetcode.com/problems/palindrome-number/"
    },
    "Longest Common Prefix": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        pref = strs[0]\n        pref_len = len(pref)\n\n        for s in strs[1:]:\n            while pref != s[0:pref_len]:\n                pref_len -= 1\n                if pref_len == 0:\n                    return \"\"\n                \n                pref = pref[0:pref_len]\n        \n        return pref"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def longestCommonPrefix(self, v: List[str]) -> str:\n        ans=\"\"\n        v=sorted(v)\n        first=v[0]\n        last=v[-1]\n        for i in range(min(len(first),len(last))):\n            if(first[i]!=last[i]):\n                return ans\n            ans+=first[i]\n        return ans \n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return \"\"\n        new = \"\"\n        strs = sorted(strs)\n        first, last = strs[0], strs[-1]\n        for i in range(len(first)):\n            if i < len(last) and first[i] == last[i]:\n                new += first[i]\n            else:\n                break\n        return new"
            }
        ],
        "source": "https://leetcode.com/problems/longest-common-prefix/"
    },
    "Valid Parentheses": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        mapping = {\")\":\"(\", \"}\":\"{\", \"]\":\"[\"}\n\n        for char in s:\n            if char in mapping.values():\n                stack.append(char)\n            elif char in mapping.keys():\n                if not stack or mapping[char] != stack.pop():\n                    return False\n        \n        return not stack"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isValid(self, s: str) -> bool:\n        stack = []\n        pairs = {')': '(', ']': '[', '}': '{'}\n        for c in s:\n            if c in \"([{\":\n                stack.append(c)\n            else:\n                if not stack or stack[-1] != pairs[c]:\n                    return False\n                stack.pop()\n        return not stack"
            }
        ],
        "source": "https://leetcode.com/problems/valid-parentheses/"
    },
    "Find the Index of the First Occurrence in a String": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def strStr(self, haystack, needle):\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        return -1"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n\n        if len(haystack) < len(needle):\n            return -1\n\n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n\n        return -1 "
            }
        ],
        "source": "https://leetcode.com/problems/implement-strstr/"
    },
    "Search Insert Position": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return left"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def searchInsert(self, nums, target):\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = left + (right - left) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left"
            }
        ],
        "source": "https://leetcode.com/problems/search-insert-position/"
    },
    "Length of Last Word": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:                \n        end = len(s) - 1\n\n        while s[end] == \" \":\n            end -= 1\n        \n        start = end\n        while start >= 0 and s[start] != \" \":\n            start -= 1\n        \n        return end - start"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        s=s.rstrip()\n        words=s.split(' ')\n        return len(words[-1])"
            }
        ],
        "source": "https://leetcode.com/problems/length-of-last-word/"
    },
    "Plus One": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n\n        for i in range(len(digits) - 1, -1, -1):\n\n            if digits[i] + 1 != 10:\n                digits[i] += 1\n                return digits\n            \n            digits[i] = 0\n\n            if i == 0:\n                return [1] + digits"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n = len(digits)\n        for i in range(n - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits"
            }
        ],
        "source": "https://leetcode.com/problems/plus-one/"
    },
    "Add Binary": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n  def addBinary(self, a: str, b: str) -> str:\n    s = []\n    carry = 0\n    i = len(a) - 1\n    j = len(b) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(a[i])\n        i -= 1\n      if j >= 0:\n        carry += int(b[j])\n        j -= 1\n      s.append(str(carry % 2))\n      carry //= 2\n\n    return ''.join(reversed(s))"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        carry = 0\n        res = []\n        \n        idxA, idxB = len(a) - 1, len(b) - 1\n        \n        while idxA >= 0 or idxB >= 0 or carry == 1:\n            if idxA >= 0:\n                carry += int(a[idxA])\n                idxA -= 1            \n            if idxB >= 0:\n                carry += int(b[idxB])\n                idxB -= 1            \n\n            res.append(str(carry % 2))\n            carry = carry // 2\n            \n        return \"\".join(res[::-1])"
            }
        ],
        "source": "https://leetcode.com/problems/add-binary/"
    },
    "Climbing Stairs": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 3: return n\n\n        prev1 = 3\n        prev2 = 2\n        cur = 0\n\n        for _ in range(3, n):\n            cur = prev1 + prev2\n            prev2 = prev1\n            prev1 = cur\n        \n        return cur"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 0 or n == 1:\n            return 1\n        return self.climbStairs(n-1) + self.climbStairs(n-2)"
            }
        ],
        "source": "https://leetcode.com/problems/climbing-stairs/"
    },
    "Best Time to Buy and Sell Stock": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        buy_price = prices[0]\n        profit = 0\n\n        for p in prices[1:]:\n            if buy_price > p:\n                buy_price = p\n            \n            profit = max(profit, p - buy_price)\n        \n        return profit"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def maxProfit(self, prices):\n        buy = prices[0]\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] < buy:\n                buy = prices[i]\n            elif prices[i] - buy > profit:\n                profit = prices[i] - buy\n        return profit"
            }
        ],
        "source": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
    },
    "Valid Palindrome": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        s = ''.join(c.lower() for c in s if c.isalnum())\n        left = 0 \n        right = len(s) - 1\n\n        while left < right:\n            if s[left] != s[right]:\n                return False\n            left += 1\n            right -= 1\n\n        return True"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        s = [c.lower() for c in s if c.isalnum()]\n        return all (s[i] == s[~i] for i in range(len(s)//2))"
            }
        ],
        "source": "https://leetcode.com/problems/valid-palindrome/"
    },
    "Excel Sheet Column Title": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        res = \"\"\n\n        while columnNumber > 0:\n            columnNumber -= 1\n            res = chr((columnNumber % 26) + ord(\"A\")) + res\n            columnNumber //= 26\n        \n        return res"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def convertToTitle(self, columnNumber: int) -> str:\n        result = []\n        while columnNumber:\n            columnNumber, remainder = divmod(columnNumber - 1, 26)\n            result.append(chr(65 + remainder))\n        return ''.join(reversed(result))"
            }
        ],
        "source": "https://leetcode.com/problems/excel-sheet-column-title/"
    },
    "Happy Number": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isHappy(self, n: int) -> bool:\n        def get_next(number):\n            return sum(int(digit) ** 2 for digit in str(number))\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isHappy(self, n: int) -> bool:    \n        visit = set()\n        \n        def get_next_number(n):    \n            output = 0\n            \n            while n:\n                digit = n % 10\n                output += digit ** 2\n                n = n // 10\n            \n            return output\n\n        while n not in visit:\n            visit.add(n)\n            n = get_next_number(n)\n            if n == 1:\n                return True\n        \n        return False"
            }
        ],
        "source": "https://leetcode.com/problems/happy-number/"
    },
    "Isomorphic Strings": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        char_index_s = {}\n        char_index_t = {}\n\n        for i in range(len(s)):\n            if s[i] not in char_index_s:\n                char_index_s[s[i]] = i\n\n            if t[i] not in char_index_t:\n                char_index_t[t[i]] = i\n            \n            if char_index_s[s[i]] != char_index_t[t[i]]:\n                return False\n\n        return True"
            },
            {
                "language": "Python",
                "code": [
                    "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        return [*map(s.index, s)] == [*map(t.index, t)]"
                ]
            }
        ],
        "source": "https://leetcode.com/problems/isomorphic-strings/"
    },
    "Contains Duplicate II": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        seen = {}\n\n        for i, val in enumerate(nums):\n            if val in seen and i - seen[val] <= k:\n                return True\n            else:\n                seen[val] = i\n        \n        return False"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\n        d = {}\n\n        for i, n in enumerate(nums):\n          if n in d and abs(i - d[n]) <= k:\n            return True\n          else:\n            d[n] = i\n        \n        return False\n\n"
            }
        ],
        "source": "https://leetcode.com/problems/contains-duplicate-ii/"
    },
    "Summary Ranges": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n\n        ranges = []\n        start = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i-1] + 1:\n                if start == nums[i-1]:\n                    ranges.append(str(start))\n                else:\n                    ranges.append(str(start) + \"->\" + str(nums[i-1]))\n                start = nums[i]\n\n        # Handle the last range\n        if start == nums[-1]:\n            ranges.append(str(start))\n        else:\n            ranges.append(str(start) + \"->\" + str(nums[-1]))\n\n        return ranges"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n\n        ranges = []\n        start = nums[0]\n\n        for i in range(1, len(nums)):\n            if nums[i] != nums[i-1] + 1:\n                if start == nums[i-1]:\n                    ranges.append(str(start))\n                else:\n                    ranges.append(str(start) + \"->\" + str(nums[i-1]))\n                start = nums[i]\n\n        # Handle the last range\n        if start == nums[-1]:\n            ranges.append(str(start))\n        else:\n            ranges.append(str(start) + \"->\" + str(nums[-1]))\n\n        return ranges"
            }
        ],
        "source": "https://leetcode.com/problems/summary-ranges/"
    },
    "Power of Two": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        for i in range(31):\n            ans = 2 ** i\n            if ans == n:\n                return True\n        return False"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isPowerOfTwo(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        if n == 1:\n            return True\n        return (n % 2 == 0) and self.isPowerOfTwo(n // 2)"
            }
        ],
        "source": "https://leetcode.com/problems/power-of-two/"
    },
    "Ugly Number": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isUgly(self, n: int) -> bool:\n# So, by this definition, a number is ugly if you can repeatedly divide it (exactly) by 2, then 3, then 5, and the sequence of values ends at 1.\n        if n <= 0:\n            return False\n            \n        while n%2 == 0:\n            n//=2\n        while n%3 == 0:\n            n//=3\n        while n%5 == 0:\n            n//=5\n        if n == 1:\n            return True\n          \n        return False"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isUgly(self, n: int) -> bool:\n        if n==0:\n            return 0\n        for i in 2,3,5:\n            while n%i==0:\n                n//=i\n        return n==1"
            }
        ],
        "source": "https://leetcode.com/problems/ugly-number/"
    },
    "Word Pattern": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        s = s.split(' ')\n        if len(s) != len(pattern):\n            return False\n        mappy1,mappy2 = {},{}\n        for i in range(len(pattern)):\n            if pattern[i] not in mappy1:\n                mappy1[pattern[i]] = s[i]\n            else:\n                if mappy1[pattern[i]] != s[i]:\n                    return False    \n            if s[i] not in mappy2:\n                mappy2[s[i]] = pattern[i] \n            else:\n                if mappy2[s[i]] != pattern[i]:\n                    return False\n        return True                \n\n        "
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def wordPattern(self, pattern: str, s: str) -> bool:\n        s = s.split(' ')\n        if len(s) != len(pattern):\n            return False\n        mappy1,mappy2 = {},{}\n        for i in range(len(pattern)):\n            if pattern[i] not in mappy1:\n                mappy1[pattern[i]] = s[i]\n            else:\n                if mappy1[pattern[i]] != s[i]:\n                    return False    \n            if s[i] not in mappy2:\n                mappy2[s[i]] = pattern[i] \n            else:\n                if mappy2[s[i]] != pattern[i]:\n                    return False\n        return True                \n\n        "
            }
        ],
        "source": "https://leetcode.com/problems/word-pattern/"
    },
    "Nim Game": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n % 4 != 0"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n % 4 != 0"
            }
        ],
        "source": "https://leetcode.com/problems/nim-game/"
    },
    "Power of Three": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        if n == 1:\n            return True\n        if n == 0:\n            return False\n\n        return (n % 3 == 0) and self.isPowerOfThree(n // 3)"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isPowerOfThree(self, n: int) -> bool:\n        if n == 1:\n            return True\n        if n == 0:\n            return False\n\n        return (n % 3 == 0) and self.isPowerOfThree(n // 3)"
            }
        ],
        "source": "https://leetcode.com/problems/power-of-three/"
    },
    "Power of Four": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        if n <= 0:\n            return False\n            \n        return math.log(n, 4).is_integer()"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isPowerOfFour(self, n):\n        # Iterate through powers of 4 from 4^0 to 4^15\n        for i in range(16):\n            power_of_four = 4 ** i\n            \n            # If we find a power of four equal to 'n', return True\n            if power_of_four == n:\n                return True\n            \n            # If the current power of four is greater than 'n', there's no need to continue\n            if power_of_four > n:\n                return False\n        \n        # 'n' is not a power of four\n        return False\n"
            }
        ],
        "source": "https://leetcode.com/problems/power-of-four/"
    },
    "Reverse Vowels of a String": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def reverseVowels(self, s: str) -> str:\n        s=list(s)\n        n=len(s)\n        left=0\n        right=n-1\n        vowels=set('AEIOUaeiou')\n        while left<right:\n            while left<right and s[left] not in vowels:\n                left+=1\n            while left<right and s[right] not in vowels:\n                right-=1\n            s[left],s[right]=s[right],s[left]\n            left+=1\n            right-=1\n        s=''.join(s)\n        return s\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def reverseVowels(self, s: str) -> str:\n        s=list(s)\n        n=len(s)\n        left=0\n        right=n-1\n        vowels=set('AEIOUaeiou')\n        while left<right:\n            while left<right and s[left] not in vowels:\n                left+=1\n            while left<right and s[right] not in vowels:\n                right-=1\n            s[left],s[right]=s[right],s[left]\n            left+=1\n            right-=1\n        s=''.join(s)\n        return s\n"
            }
        ],
        "source": "https://leetcode.com/problems/reverse-vowels-of-a-string/"
    },
    "Intersection of Two Arrays II": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        if len(nums1) > len(nums2): return self.intersect(nums2, nums1)\n            \n        cnt = Counter(nums1)\n        ans = []\n        for x in nums2:\n            if cnt[x] > 0:\n                ans.append(x)\n                cnt[x] -= 1\n        return ans"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        arr = [0] * 1001\n        result = []\n        for num in nums1:\n            arr[num] += 1\n\n        for num in nums2:\n            if arr[num] > 0:\n                result.append(num)\n                arr[num] -= 1\n\n        return result[: len(result)]"
            }
        ],
        "source": "https://leetcode.com/problems/intersection-of-two-arrays-ii/"
    },
    "Valid Perfect Square": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        nums = [1,      4,      9,      16,     25,     36,     49,     64,\n            81,     100,    121,    144,    169,    196,    225,    256,\n            289,    324,    361,    400,    441,    484,    529,    576,\n            625,    676,    729,    784,    841,    900,    961,    1024,\n            1089,   1156,   1225,   1296,   1369,   1444,   1521,   1600,\n            1681,   1764,   1849,   1936,   2025,   2116,   2209,   2304,\n            2401,   2500,   2601,   2704,   2809,   2916,   3025,   3136,\n            3249,   3364,   3481,   3600,   3721,   3844,   3969,   4096,\n            4225,   4356,   4489,   4624,   4761,   4900,   5041,   5184,\n            5329,   5476,   5625,   5776,   5929,   6084,   6241,   6400,\n            6561,   6724,   6889,   7056,   7225,   7396,   7569,   7744,\n            7921,   8100,   8281,   8464,   8649,   8836,   9025,   9216,\n            9409,   9604,   9801,   10000,  10201,  10404,  10609,  10816,\n            11025,  11236,  11449,  11664,  11881,  12100,  12321,  12544,\n            12769,  12996,  13225,  13456,  13689,  13924,  14161,  14400,\n            14641,  14884,  15129,  15376,  15625,  15876,  16129,  16384,\n            16641,  16900,  17161,  17424,  17689,  17956,  18225,  18496,\n            18769,  19044,  19321,  19600,  19881,  20164,  20449,  20736,\n            21025,  21316,  21609,  21904,  22201,  22500,  22801,  23104,\n            23409,  23716,  24025,  24336,  24649,  24964,  25281,  25600,\n            25921,  26244,  26569,  26896,  27225,  27556,  27889,  28224,\n            28561,  28900,  29241,  29584,  29929,  30276,  30625,  30976,\n            31329,  31684,  32041,  32400,  32761,  33124,  33489,  33856,\n            34225,  34596,  34969,  35344,  35721,  36100,  36481,  36864,\n            37249,  37636,  38025,  38416,  38809,  39204,  39601,  40000,\n            40401,  40804,  41209,  41616,  42025,  42436,  42849,  43264,\n            43681,  44100,  44521,  44944,  45369,  45796,  46225,  46656,\n            47089,  47524,  47961,  48400,  48841,  49284,  49729,  50176,\n            50625,  51076,  51529,  51984,  52441,  52900,  53361,  53824,\n            54289,  54756,  55225,  55696,  56169,  56644,  57121,  57600,\n            58081,  58564,  59049,  59536,  60025,  60516,  61009,  61504,\n            62001,  62500,  63001,  63504,  64009,  64516,  65025,  65536,\n            66049,  66564,  67081,  67600,  68121,  68644,  69169,  69696,\n            70225,  70756,  71289,  71824,  72361,  72900,  73441,  73984,\n            74529,  75076,  75625,  76176,  76729,  77284,  77841,  78400,\n            78961,  79524,  80089,  80656,  81225,  81796,  82369,  82944,\n            83521,  84100,  84681,  85264,  85849,  86436,  87025,  87616,\n            88209,  88804,  89401,  90000,  90601,  91204,  91809,  92416,\n            93025,  93636,  94249,  94864,  95481,  96100,  96721,  97344,\n            97969,  98596,  99225,  99856,  100489, 101124, 101761, 102400,\n            103041, 103684, 104329, 104976, 105625, 106276, 106929, 107584,\n            108241, 108900, 109561, 110224, 110889, 111556, 112225, 112896,\n            113569, 114244, 114921, 115600, 116281, 116964, 117649, 118336,\n            119025, 119716, 120409, 121104, 121801, 122500, 123201, 123904,\n            124609, 125316, 126025, 126736, 127449, 128164, 128881, 129600,\n            130321, 131044, 131769, 132496, 133225, 133956, 134689, 135424,\n            136161, 136900, 137641, 138384, 139129, 139876, 140625, 141376,\n            142129, 142884, 143641, 144400, 145161, 145924, 146689, 147456,\n            148225, 148996, 149769, 150544, 151321, 152100, 152881, 153664,\n            154449, 155236, 156025, 156816, 157609, 158404, 159201, 160000,\n            160801, 161604, 162409, 163216, 164025, 164836, 165649, 166464,\n            167281, 168100, 168921, 169744, 170569, 171396, 172225, 173056,\n            173889, 174724, 175561, 176400, 177241, 178084, 178929, 179776,\n            180625, 181476, 182329, 183184, 184041, 184900, 185761, 186624,\n            187489, 188356, 189225, 190096, 190969, 191844, 192721, 193600,\n            194481, 195364, 196249, 197136, 198025, 198916, 199809, 200704,\n            201601, 202500, 203401, 204304, 205209, 206116, 207025, 207936,\n            208849, 209764, 210681, 211600, 212521, 213444, 214369, 215296,\n            216225, 217156, 218089, 219024, 219961, 220900, 221841, 222784,\n            223729, 224676, 225625, 226576, 227529, 228484, 229441, 230400,\n            231361, 232324, 233289, 234256, 235225, 236196, 237169, 238144,\n            239121, 240100, 241081, 242064, 243049, 244036, 245025, 246016,\n            247009, 248004, 249001, 250000, 251001, 252004, 253009, 254016,\n            255025, 256036, 257049, 258064, 259081, 260100, 261121, 262144,\n            263169, 264196, 265225, 266256, 267289, 268324, 269361, 270400,\n            271441, 272484, 273529, 274576, 275625, 276676, 277729, 278784,\n            279841, 280900, 281961, 283024, 284089, 285156, 286225, 287296,\n            288369, 289444, 290521, 291600, 292681, 293764, 294849, 295936,\n            297025, 298116, 299209, 300304, 301401, 302500, 303601, 304704,\n            305809, 306916, 308025, 309136, 310249, 311364, 312481, 313600,\n            314721, 315844, 316969, 318096, 319225, 320356, 321489, 322624,\n            323761, 324900, 326041, 327184, 328329, 329476, 330625, 331776,\n            332929, 334084, 335241, 336400, 337561, 338724, 339889, 341056,\n            342225, 343396, 344569, 345744, 346921, 348100, 349281, 350464,\n            351649, 352836, 354025, 355216, 356409, 357604, 358801, 360000,\n            361201, 362404, 363609, 364816, 366025, 367236, 368449, 369664,\n            370881, 372100, 373321, 374544, 375769, 376996, 378225, 379456,\n            380689, 381924, 383161, 384400, 385641, 386884, 388129, 389376,\n            390625, 391876, 393129, 394384, 395641, 396900, 398161, 399424,\n            400689, 401956, 403225, 404496, 405769, 407044, 408321, 409600,\n            410881, 412164, 413449, 414736, 416025, 417316, 418609, 419904,\n            421201, 422500, 423801, 425104, 426409, 427716, 429025, 430336,\n            431649, 432964, 434281, 435600, 436921, 438244, 439569, 440896,\n            442225, 443556, 444889, 446224, 447561, 448900, 450241, 451584,\n            452929, 454276, 455625, 456976, 458329, 459684, 461041, 462400,\n            463761, 465124, 466489, 467856, 469225, 470596, 471969, 473344,\n            474721, 476100, 477481, 478864, 480249, 481636, 483025, 484416,\n            485809, 487204, 488601, 490000, 491401, 492804, 494209, 495616,\n            497025, 498436, 499849, 501264, 502681, 504100, 505521, 506944,\n            508369, 509796, 511225, 512656, 514089, 515524, 516961, 518400,\n            519841, 521284, 522729, 524176, 525625, 527076, 528529, 529984,\n            531441, 532900, 534361, 535824, 537289, 538756, 540225, 541696,\n            543169, 544644, 546121, 547600, 549081, 550564, 552049, 553536,\n            555025, 556516, 558009, 559504, 561001, 562500, 564001, 565504,\n            567009, 568516, 570025, 571536, 573049, 574564, 576081, 577600,\n            579121, 580644, 582169, 583696, 585225, 586756, 588289, 589824,\n            591361, 592900, 594441, 595984, 597529, 599076, 600625, 602176,\n            603729, 605284, 606841, 608400, 609961, 611524, 613089, 614656,\n            616225, 617796, 619369, 620944, 622521, 624100, 625681, 627264,\n            628849, 630436, 632025, 633616, 635209, 636804, 638401, 640000,\n            641601, 643204, 644809, 646416, 648025, 649636, 651249, 652864,\n            654481, 656100, 657721, 659344, 660969, 662596, 664225, 665856,\n            667489, 669124, 670761, 672400, 674041, 675684, 677329, 678976,\n            680625, 682276, 683929, 685584, 687241, 688900, 690561, 692224,\n            693889, 695556, 697225, 698896, 700569, 702244, 703921, 705600,\n            707281, 708964, 710649, 712336, 714025, 715716, 717409, 719104,\n            720801, 722500, 724201, 725904, 727609, 729316, 731025, 732736,\n            734449, 736164, 737881, 739600, 741321, 743044, 744769, 746496,\n            748225, 749956, 751689, 753424, 755161, 756900, 758641, 760384,\n            762129, 763876, 765625, 767376, 769129, 770884, 772641, 774400,\n            776161, 777924, 779689, 781456, 783225, 784996, 786769, 788544,\n            790321, 792100, 793881, 795664, 797449, 799236, 801025, 802816,\n            804609, 806404, 808201, 810000, 811801, 813604, 815409, 817216,\n            819025, 820836, 822649, 824464, 826281, 828100, 829921, 831744,\n            833569, 835396, 837225, 839056, 840889, 842724, 844561, 846400,\n            848241, 850084, 851929, 853776, 855625, 857476, 859329, 861184,\n            863041, 864900, 866761, 868624, 870489, 872356, 874225, 876096,\n            877969, 879844, 881721, 883600, 885481, 887364, 889249, 891136,\n            893025, 894916, 896809, 898704, 900601, 902500, 904401, 906304,\n            908209, 910116, 912025, 913936, 915849, 917764, 919681, 921600,\n            923521, 925444, 927369, 929296, 931225, 933156, 935089, 937024,\n            938961, 940900, 942841, 944784, 946729, 948676, 950625, 952576,\n            954529, 956484, 958441, 960400, 962361, 964324, 966289, 968256,\n            970225, 972196, 974169, 976144, 978121, 980100, 982081, 984064,\n            986049, 988036, 990025, 992016, 994009, 996004, 998001, 2147395600]\n            \n        for x in nums:\n            if x == num:\n                return True\n        return False"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        x = num\n        while x * x > num:\n            x = (x + num // x) // 2\n        return x * x == num\n        \n        "
            }
        ],
        "source": "https://leetcode.com/problems/valid-perfect-square/"
    },
    "Find the Difference": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n        # Initialize a dictionary to store character counts\n        count = {}\n\n        # Count characters in string t\n        for c in t:\n            count[c] = count.get(c, 0) + 1\n\n        # Subtract counts for characters in string s\n        for c in s:\n            count[c] -= 1\n            if count[c] == 0:\n                del count[c]\n\n        # The remaining character in the dictionary is the difference\n        return list(count.keys())[0]"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def findTheDifference(self, s: str, t: str) -> str:\n\n        for i in t:\n            if s.count(i) != t.count(i):\n                return i\n            "
            }
        ],
        "source": "https://leetcode.com/problems/find-the-difference/"
    },
    "Is Subsequence": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        sp = tp = 0\n\n        while sp < len(s) and tp < len(t):\n            if s[sp] == t[tp]:\n                sp += 1\n            tp += 1\n        \n        return sp == len(s)"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isSubsequence(self, s: str, t: str) -> bool:\n        j = 0\n        for char in t:\n            if j < len(s) and s[j] == char:\n                j += 1\n        return j == len(s)"
            }
        ],
        "source": "https://leetcode.com/problems/is-subsequence/"
    },
    "Binary Watch": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        res = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.append(f\"{h}:{m:02d}\")\n        return res"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        res = []\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:\n                    res.append(f\"{h}:{m:02d}\")\n        return res"
            }
        ],
        "source": "https://leetcode.com/problems/binary-watch/"
    },
    "Convert a Number to Hexadecimal": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def toHex(self, num: int) -> str:\n        d = {10:'a',11:'b',12:'c',13:'d',14:'e',15:'f'}\n        res = \"\"\n        if num == 0:\n            return \"0\"\n        if num<0:\n            num = (1<<32)+num\n        while num>0:\n            if num%16<10:\n                res+=str(num%16)\n            else:\n                res+=str(d[num%16])\n            num=num//16\n        return res[::-1]"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def toHex(self, num: int) -> str:\n        if num == 0:\n            return \"0\"\n        if num < 0:\n            num += 2**32\n        hex_str = hex(num)[2:]\n        return hex_str"
            }
        ],
        "source": "https://leetcode.com/problems/convert-a-number-to-hexadecimal/"
    },
    "Longest Palindrome": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        k = set(s)\n        m = list(s)\n        n = []\n        for i in k:\n            if(s.count(i)%2 == 1):\n                n.append(i)\n                m.remove(i)\n        if len(n)!=0:\n            return len(m)+1\n        else:\n            return len(m)\n        "
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        # Initialize a set to keep track of characters with odd frequencies\n        char_set = set()\n        # Initialize the length of the longest palindrome\n        length = 0\n        \n        # Iterate over each character in the string\n        for char in s:\n            # If the character is already in the set, remove it and increase the length by 2\n            if char in char_set:\n                char_set.remove(char)\n                length += 2\n            # If the character is not in the set, add it to the set\n            else:\n                char_set.add(char)\n        \n        # If there are any characters left in the set, add 1 to the length for the middle character\n        if char_set:\n            length += 1\n        \n        # Return the total length of the longest palindrome\n        return length"
            }
        ],
        "source": "https://leetcode.com/problems/longest-palindrome/"
    },
    "Add Strings": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        return str(int(num1)+int(num2))\n\"\"\"\nclass Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        i, j = len(num1) - 1, len(num2) - 1\n        carry = 0\n        result = []\n\n        while i >= 0 or j >= 0 or carry:\n            digit1 = int(num1[i]) if i >= 0 else 0\n            digit2 = int(num2[j]) if j >= 0 else 0\n\n            total = digit1 + digit2 + carry\n            carry = total // 10\n\n            result.append(str(total % 10))\n\n            i -= 1\n            j -= 1\n\n        return ''.join(result[::-1])\n\"\"\""
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        \n        def str2int(num):\n            numDict = {'0' : 0, '1' : 1, '2' : 2, '3' : 3, '4' : 4, '5' : 5,\n                  '6' : 6, '7' : 7, '8' : 8, '9' : 9}\n            output = 0\n            for d in num:\n                output = output * 10 + numDict[d]\n            return output\n        \n        return str(str2int(num1) + str2int(num2)) "
            }
        ],
        "source": "https://leetcode.com/problems/add-strings/"
    },
    "Arranging Coins": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        if n == 1:\n            return 1\n        \n        for i in range(1, n + 1):\n            n -= i\n            if (n < 0):\n                return i - 1"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def arrangeCoins(self, n: int) -> int:\n        if n == 1:\n            return 1\n        \n        for i in range(1, n + 1):\n            n -= i\n            if (n < 0):\n                return i - 1"
            }
        ],
        "source": "https://leetcode.com/problems/arranging-coins/"
    },
    "Assign Cookies": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort(reverse = True)\n        s.sort(reverse = True)\n        res, i , j = 0 ,0,0\n        while i<len(g) and j<len(s):\n            if g[i]<=s[j]:\n                res+=1\n                i+=1\n                j+=1\n            else:\n                i+=1\n        return res"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        count = 0\n        i, j = 0, 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"
            }
        ],
        "source": "https://leetcode.com/problems/assign-cookies/"
    },
    "Repeated Substring Pattern": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        n = len(s)\n        for i in range(1, n // 2 + 1):\n            if n % i == 0 and s[:i] * (n // i) == s:\n                return True\n        \n        return False"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def repeatedSubstringPattern(self, s: str) -> bool:\n        \n        s_fold = \"\".join( (s[1:], s[:-1]) )\n        \n        return s in s_fold"
            }
        ],
        "source": "https://leetcode.com/problems/repeated-substring-pattern/"
    },
    "License Key Formatting": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        string = ''\n        for char in s:\n            if char != '-':\n                string += char.upper()\n        \n        mod = len(string) % k\n        print(mod)\n        res = ''\n\n        if mod != 0:\n            res += string[0:mod]\n            res += '-'\n\n        for i in range(mod, len(string), k):\n            res += string[i: i+k]\n            res += '-'\n        return res[:-1]\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def licenseKeyFormatting(self, s: str, k: int) -> str:\n        string = ''\n        for char in s:\n            if char != '-':\n                string += char.upper()\n        \n        mod = len(string) % k\n        print(mod)\n        res = ''\n\n        if mod != 0:\n            res += string[0:mod]\n            res += '-'\n\n        for i in range(mod, len(string), k):\n            res += string[i: i+k]\n            res += '-'\n        return res[:-1]\n"
            }
        ],
        "source": "https://leetcode.com/problems/license-key-formatting/"
    },
    "Construct the Rectangle": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def constructRectangle(self, area: int) -> List[int]:\n        for l in range(int(area**0.5), 0, -1):            \n            if area % l == 0: \n                return [area // l, l]"
            },
            {
                "language": "Python",
                "code": "from math import sqrt\n\nclass Solution:\n    def constructRectangle(self, area: int) -> List[int]:\n        for i in range(int(sqrt(area)), 0, -1):\n            if area % i == 0:\n                return [area // i, i]"
            }
        ],
        "source": "https://leetcode.com/problems/construct-the-rectangle/"
    },
    "Teemo Attacking": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        count = 0\n        length = len(timeSeries) - 1\n        for i in range(length + 1):\n            if i == length or timeSeries[i] + duration - 1 < timeSeries[i + 1]:\n                count += duration\n            else:\n                count += timeSeries[i + 1] - timeSeries[i]\n        return count"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        count = 0\n        length = len(timeSeries) - 1\n        for i in range(length + 1):\n            if i == length or timeSeries[i] + duration - 1 < timeSeries[i + 1]:\n                count += duration\n            else:\n                count += timeSeries[i + 1] - timeSeries[i]\n        return count"
            }
        ],
        "source": "https://leetcode.com/problems/teemo-attacking/"
    },
    "Base 7": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def convertToBase7(self, num: int) -> str:\n        # Handle the edge case where num is 0\n        if num == 0:\n            return \"0\"\n        \n        # Initialize a flag to keep track of whether num is negative or not\n        is_negative = num < 0\n        \n        # Convert num to positive if it's negative\n        if is_negative:\n            num = -num\n        \n        # Initialize a variable to keep track of the base 7 representation\n        base_7 = \"\"\n        \n        # Loop until num becomes 0\n        while num > 0:\n            # Compute the remainder when num is divided by 7\n            remainder = num % 7\n            \n            # Add the remainder to the base 7 representation\n            base_7 = str(remainder) + base_7\n            \n            # Update num to be the quotient when it's divided by 7\n            num //= 7\n        \n        # If num was originally negative, add a '-' sign to the base 7 representation\n        if is_negative:\n            base_7 = '-' + base_7\n        \n        # Return the base 7 representation\n        return base_7\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def convertToBase7(self, num: int) -> str:\n        # Handle the edge case where num is 0\n        if num == 0:\n            return \"0\"\n        \n        # Initialize a flag to keep track of whether num is negative or not\n        is_negative = num < 0\n        \n        # Convert num to positive if it's negative\n        if is_negative:\n            num = -num\n        \n        # Initialize a variable to keep track of the base 7 representation\n        base_7 = \"\"\n        \n        # Loop until num becomes 0\n        while num > 0:\n            # Compute the remainder when num is divided by 7\n            remainder = num % 7\n            \n            # Add the remainder to the base 7 representation\n            base_7 = str(remainder) + base_7\n            \n            # Update num to be the quotient when it's divided by 7\n            num //= 7\n        \n        # If num was originally negative, add a '-' sign to the base 7 representation\n        if is_negative:\n            base_7 = '-' + base_7\n        \n        # Return the base 7 representation\n        return base_7\n"
            }
        ],
        "source": "https://leetcode.com/problems/base-7/"
    },
    "Perfect Number": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        if num % 2 != 0:\n            return False\n        count = 1\n        i = 2\n        j = num//2\n        while i < j:\n            if num%i == 0:\n                count += i\n            if num%j == 0:\n                count += j\n            i += 1\n            j -= 1\n        return count == num\n        "
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def checkPerfectNumber(self, num: int) -> bool:\n        if num % 2 != 0:\n            return False\n        count = 1\n        i = 2\n        j = num//2\n        while i < j:\n            if num%i == 0:\n                count += i\n            if num%j == 0:\n                count += j\n            i += 1\n            j -= 1\n        return count == num\n        "
            }
        ],
        "source": "https://leetcode.com/problems/perfect-number/"
    },
    "Zigzag Conversion": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1 or numRows >= len(s):\n            return s\n\n        idx, d = 0, 1\n        rows = [[] for _ in range(numRows)]\n\n        for char in s:\n            rows[idx].append(char)\n            if idx == 0:\n                d = 1\n            elif idx == numRows - 1:\n                d = -1\n            idx += d\n\n        for i in range(numRows):\n            rows[i] = ''.join(rows[i])\n\n        return ''.join(rows)   "
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def convert(self, s: str, numRows: int) -> str:\n        if numRows == 1:\n            return s\n\n        rows = [\"\"] * numRows\n        \n        add = 0\n        inc = 1\n        for i in s:\n            rows[add] += i\n            if add == 0:\n                inc = 1\n            elif add == numRows - 1:\n                inc = -1\n\n            add += inc\n            \n        return \"\".join(rows)"
            }
        ],
        "source": "https://leetcode.com/problems/zigzag-conversion/"
    },
    "Container With Most Water": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n\n        while left < right:\n            max_area = max(max_area, (right - left) * min(height[left], height[right]))\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        \n        return max_area"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        left = 0\n        right = len(height) - 1\n        maxArea = 0\n\n        while left < right:\n            currentArea = min(height[left], height[right]) * (right - left)\n            maxArea = max(maxArea, currentArea)\n\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return maxArea"
            }
        ],
        "source": "https://leetcode.com/problems/container-with-most-water/"
    },
    "3Sum Closest": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \n        nums.sort()\n        closest = float('inf')\n        n = len(nums)\n        if sum(nums[:3])>target:\n            return sum(nums[:3])\n        if sum(nums[-3:])<target:\n            return sum(nums[-3:])\n            \n        for i in range(n-2):\n            left,right=i+1,n-1\n            while left<right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                if abs(current_sum-target) < abs(closest-target):\n                    closest = current_sum\n                if current_sum < target:\n                    left += 1\n                elif current_sum > target:\n                    right -= 1\n                else:\n                    return current_sum\n        return closest"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        closest = nums[0]+nums[1]+nums[2]\n        for i in range(len(nums)-2):\n            for j in range(i+1, len(nums)-1):\n                for k in range(j+1, len(nums)):\n                    if abs(target-(nums[i]+nums[j]+nums[k]))< abs(target-closest):\n                        closest = nums[i]+nums[j]+nums[k]\n        return closest\n"
            }
        ],
        "source": "https://leetcode.com/problems/3sum-closest/"
    },
    "Search in Rotated Sorted Array": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n\n        left = 0\n        right = len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] >= nums[left]:\n                if nums[left] <= target <= nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] <= target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        return -1"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            # Check if left half is sorted\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            # Otherwise, right half is sorted\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n\n        return -1"
            }
        ],
        "source": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
    },
    "Find First and Last Position of Element in Sorted Array": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \n        def search(x):\n            lo, hi = 0, len(nums)           \n            while lo < hi:\n                mid = (lo + hi) // 2\n                if nums[mid] < x:\n                    lo = mid+1\n                else:\n                    hi = mid                    \n            return lo\n        \n        lo = search(target)\n        hi = search(target+1)-1\n        \n        if lo <= hi:\n            return [lo, hi]\n                \n        return [-1, -1]"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\n        \n        def binary_search(nums, target, is_searching_left):\n            left = 0\n            right = len(nums) - 1\n            idx = -1\n            \n            while left <= right:\n                mid = (left + right) // 2\n                \n                if nums[mid] > target:\n                    right = mid - 1\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    idx = mid\n                    if is_searching_left:\n                        right = mid - 1\n                    else:\n                        left = mid + 1\n            \n            return idx\n        \n        left = binary_search(nums, target, True)\n        right = binary_search(nums, target, False)\n        \n        return [left, right]\n            "
            }
        ],
        "source": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/"
    },
    "Count and Say": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        if n==1:\n            return \"1\"\n        x=self.countAndSay(n-1)\n        s=\"\"\n        y=x[0]\n        ct=1\n        for i in range(1,len(x)):\n            if x[i]==y:\n                ct+=1\n            else:\n                s+=str(ct)\n                s+=str(y)\n                y=x[i]\n                ct=1\n        s+=str(ct)\n        s+=str(y)\n        return s"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def countAndSay(self, n: int) -> str:\n        if n==1:\n            return \"1\"\n        x=self.countAndSay(n-1)\n        s=\"\"\n        y=x[0]\n        ct=1\n        for i in range(1,len(x)):\n            if x[i]==y:\n                ct+=1\n            else:\n                s+=str(ct)\n                s+=str(y)\n                y=x[i]\n                ct=1\n        s+=str(ct)\n        s+=str(y)\n        return s"
            }
        ],
        "source": "https://leetcode.com/problems/count-and-say/"
    },
    "Combination Sum II": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def combinationSum2(self, nums: List[int], target: int) -> List[List[int]]:\n\n        result = []\n        nums.sort()\n\n        def _backtrack(ind,arr,k,result):\n\n            if k == 0:\n                result.append(arr[:])\n                return\n            \n            if k < 0:\n                return\n\n            \n            for j in range(ind,len(nums)):\n\n                if nums[j] > k: \n                    break\n\n                if j > ind and nums[j] == nums[j - 1]:\n                    continue\n                \n\n                arr.append(nums[j])\n\n                _backtrack(j + 1, arr, k - nums[j], result)\n\n                arr.pop()\n\n\n        _backtrack(0,[],target,result)\n\n        return result\n        "
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        res = []\n\n        def dfs(target, start, comb):\n            if target < 0:\n                return\n            if target == 0:\n                res.append(comb)\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                dfs(target-candidates[i], i+1, comb+[candidates[i]])\n\n        dfs(target, 0, [])\n        return res\n"
            }
        ],
        "source": "https://leetcode.com/problems/combination-sum-ii/"
    },
    "Multiply Strings": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        return str(int(num1)*int(num2))"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def multiply(self, num1: str, num2: str) -> str:\n        return str(int(num1)*int(num2))"
            }
        ],
        "source": "https://leetcode.com/problems/multiply-strings/"
    },
    "Jump Game II": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        near = far = jumps = 0\n\n        while far < len(nums) - 1:\n            farthest = 0\n            for i in range(near, far + 1):\n                farthest = max(farthest, i + nums[i])\n            \n            near = far + 1\n            far = farthest\n            jumps += 1\n        \n        return jumps"
            },
            {
                "language": "Python",
                "code": "class Solution:\n  def jump(self, nums: List[int]) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    # Implicit BFS\n    for i in range(len(nums) - 1):\n      farthest = max(farthest, i + nums[i])\n      if farthest >= len(nums) - 1:\n        ans += 1\n        break\n      if i == end:      # Visited all the items on the current level\n        ans += 1        # Increment the level\n        end = farthest  # Make the queue size for the next level\n\n    return ans"
            }
        ],
        "source": "https://leetcode.com/problems/jump-game-ii/"
    },
    "Maximum Subarray": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:            \n        res = nums[0]\n        total = 0\n\n        for n in nums:\n            if total < 0:\n                total = 0\n\n            total += n\n            res = max(res, total)\n        \n        return res"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        maxSubArr = nums[0]\n        \n        currSum = 0\n        \n        for n in nums:\n            if currSum<0:\n                currSum = 0\n            \n            currSum+=n\n            \n            maxSubArr = max(maxSubArr,currSum)\n            \n        return maxSubArr"
            }
        ],
        "source": "https://leetcode.com/problems/maximum-subarray/"
    },
    "Spiral Matrix": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        rows, cols = len(matrix), len(matrix[0])\n        x, y, dx, dy = 0, 0, 1, 0\n        res = []\n\n        for _ in range(rows * cols):\n            res.append(matrix[y][x])\n            matrix[y][x] = \".\"\n\n            if not 0 <= x + dx < cols or not 0 <= y + dy < rows or matrix[y+dy][x+dx] == \".\":\n                dx, dy = -dy, dx\n            \n            x += dx\n            y += dy\n        \n        return res"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        rows, cols = len(matrix), len(matrix[0])\n        top, bottom, left, right = 0, rows - 1, 0, cols - 1\n        res = []\n\n        while top <= bottom and left <= right:\n            # top edge\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            \n            # right edge\n            for i in range(top + 1, bottom + 1):\n                res.append(matrix[i][right])\n            \n            # bottom edge, it not the same as top\n            if top != bottom:\n                for i in range(right - 1, left - 1, -1):\n                    res.append(matrix[bottom][i])\n            \n            # left edge, if not the same as right\n            if left != right:\n                for i in range(bottom - 1, top, -1):\n                    res.append(matrix[i][left])\n            \n            top += 1\n            left += 1\n            right -= 1\n            bottom -= 1\n        \n        return res"
            }
        ],
        "source": "https://leetcode.com/problems/spiral-matrix/"
    },
    "Merge Intervals": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:        \n        merged = []\n        intervals.sort(key=lambda x: x[0])\n\n        prev = intervals[0]\n\n        for interval in intervals[1:]:\n            if interval[0] <= prev[1]:\n                prev[1] = max(prev[1], interval[1])\n            else:\n                merged.append(prev)\n                prev = interval\n        \n        merged.append(prev)\n\n        return merged"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals = sorted(intervals, key=lambda x: x [0])\n\n        ans = []\n\n        for interval in intervals:\n            if not ans or ans[-1][1] < interval[0]:\n                ans.append(interval)\n            else:\n                ans[-1][1] = max(ans[-1][1], interval[1])\n        \n        return ans"
            }
        ],
        "source": "https://leetcode.com/problems/merge-intervals/"
    },
    "Insert Interval": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        intervals.append(newInterval)\n        intervals.sort()\n\n        res = [intervals[0]]\n\n        for i in range(1, len(intervals)):\n            if res[-1][1] >= intervals[i][0]:\n                res[-1][1] = max(res[-1][1], intervals[i][1])\n            else:\n                res.append(intervals[i])\n\n        return res"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        output = []\n\n        newStart = newInterval[0]\n        newEnd = newInterval[1]\n\n        i = 0\n        n = len(intervals)\n\n        # Add all intervals that come before the new interval\n        while i < n and newStart > intervals[i][0]:\n            output.append(intervals[i])\n            i += 1\n\n        # Merge newInterval with the last interval in output if necessary\n        if not output or output[-1][1] < newStart:\n            output.append(newInterval)\n        else:\n            output[-1][1] = max(output[-1][1], newEnd)\n\n        # Add remaining intervals, merging if necessary\n        while i < n:\n            start, end = intervals[i]\n\n            if output[-1][1] < start:\n                output.append([start, end])\n            else:\n                output[-1][1] = max(output[-1][1], end)\n            i += 1\n\n        return output\n"
            }
        ],
        "source": "https://leetcode.com/problems/insert-interval/"
    },
    "Unique Paths II": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        if not obstacleGrid or obstacleGrid[0][0] == 1:\n            return 0\n\n        rows, cols = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [0] * cols\n        dp[0] = 1\n\n        for r in range(rows):\n            for c in range(cols):\n                if obstacleGrid[r][c] == 1:\n                    dp[c] = 0\n                else:\n                    if c > 0:\n                        dp[c] += dp[c - 1]\n\n        return dp[cols - 1] "
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        if not obstacleGrid or not obstacleGrid[0] or obstacleGrid[0][0] == 1:\n            return 0\n        \n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        \n        previous = [0] * n\n        current = [0] * n\n        previous[0] = 1\n        \n        for i in range(m):\n            current[0] = 0 if obstacleGrid[i][0] == 1 else previous[0]\n            for j in range(1, n):\n                current[j] = 0 if obstacleGrid[i][j] == 1 else current[j-1] + previous[j]\n            previous[:] = current\n        \n        return previous[n-1]"
            }
        ],
        "source": "https://leetcode.com/problems/unique-paths-ii/"
    },
    "Simplify Path": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        components = path.split(\"/\")\n        st = []\n\n        for comp in components:\n            if comp == \"\" or comp == \".\":\n                continue\n            \n            if comp == \"..\":\n                if st:\n                    st.pop()\n            else:\n                st.append(comp)\n        \n        return \"/\" + \"/\".join(st)"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def simplifyPath(self, path):\n        dir_stack = []\n        path = path.split(\"/\")\n        for elem in path:\n            if dir_stack and elem == \"..\":\n                dir_stack.pop()\n            elif elem not in [\".\", \"\", \"..\"]:\n                dir_stack.append(elem)\n                \n        return \"/\" + \"/\".join(dir_stack)\n"
            }
        ],
        "source": "https://leetcode.com/problems/simplify-path/"
    },
    "Edit Distance": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    m = len(word1)\n    n = len(word2)\n    # dp[i][j] := min # Of operations to convert word1[0..i) to word2[0..j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      dp[i][0] = i\n\n    for j in range(1, n + 1):\n      dp[0][j] = j\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if word1[i - 1] == word2[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1]\n        else:\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n\n    return dp[m][n]"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def minDistance(self, word1, word2):\n        \"\"\"Naive recursive solution\"\"\"\n        if not word1 and not word2:\n            return 0\n        if not word1:\n            return len(word2)\n        if not word2:\n            return len(word1)\n        if word1[0] == word2[0]:\n            return self.minDistance(word1[1:], word2[1:])\n        insert = 1 + self.minDistance(word1, word2[1:])\n        delete = 1 + self.minDistance(word1[1:], word2)\n        replace = 1 + self.minDistance(word1[1:], word2[1:])\n        return min(insert, replace, delete)"
            }
        ],
        "source": "https://leetcode.com/problems/edit-distance/"
    },
    "Search a 2D Matrix": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \n        top = 0\n        bot = len(matrix) - 1\n\n        while top <= bot:\n            mid = (top + bot) // 2\n\n            if matrix[mid][0] < target and matrix[mid][-1] > target:\n                break\n            elif matrix[mid][0] > target:\n                bot = mid - 1\n            else:\n                top = mid + 1\n        \n        row = (top + bot) // 2\n\n        left = 0\n        right = len(matrix[row]) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if matrix[row][mid] == target:\n                return True\n            elif matrix[row][mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        return False"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        \"\"\"\n        Increasing order in zigzag fashion\n        search space: matrix[0][0] (smallest number) to matrix[row-1][col-1] (largest number)\n        binary search O(logX) complexity. X = m*n (number of cells in matrix)\n\n        Have to map index to corresponding row & col of 2D matrix\n        \"\"\"\n\n        rows, cols = len(matrix), len(matrix[0])\n        start, end = 0, rows*cols-1\n\n        while start <= end:\n            mid = (start+end)//2\n            row = mid//cols\n            col = mid%cols\n            if matrix[row][col] < target:\n                start = mid + 1\n            elif matrix[row][col] > target:\n                end = mid - 1\n            elif matrix[row][col] == target:\n                return True\n        return False"
            }
        ],
        "source": "https://leetcode.com/problems/search-a-2d-matrix/"
    },
    "Word Search": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def exist(self, board, word):\n        def backtrack(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            \n            temp = board[i][j]\n            board[i][j] = ''\n            \n            if backtrack(i+1, j, k+1) or backtrack(i-1, j, k+1) or backtrack(i, j+1, k+1) or backtrack(i, j-1, k+1):\n                return True\n            \n            board[i][j] = temp\n            return False\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if backtrack(i, j, 0):\n                    return True\n        return False"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n    \n        rows, cols = len(board), len(board[0])\n        visited = set()\n\n        def dfs(r, c, k):\n            if k == len(word):\n                return True\n\n            if not (0 <= r < rows) or not (0 <= c < cols) or (r,c) in visited or board[r][c] != word[k]:\n                return False\n            \n            visited.add((r,c))\n            res = dfs(r+1, c, k+1) or dfs(r-1, c, k+1) or dfs(r, c+1, k+1) or dfs(r, c-1, k+1)\n            visited.remove((r,c))\n            return res\n             \n        count = {}\n        for c in word:\n            count[c] = 1 + count.get(c, 0)\n        \n        if count[word[0]] > count[word[-1]]:\n            word = word[::-1]\n        \n        for r in range(rows):\n            for c in range(cols):\n                if dfs(r, c, 0): return True\n        \n        return False"
            }
        ],
        "source": "https://leetcode.com/problems/word-search/"
    },
    "Subsets II": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n  def subsetsWithDup(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n    def dfs(s: int, path: list[int]) -> None:\n      ans.append(path)\n      if s == len(nums):\n        return\n\n      for i in range(s, len(nums)):\n        if i > s and nums[i] == nums[i - 1]:\n          continue\n        dfs(i + 1, path + [nums[i]])\n\n    nums.sort()\n    dfs(0, [])\n    return ans"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def subsetsWithDup(self, nums):\n        def f(index, t):\n            ans.append(list(t))\n\n            for i in range(index, len(nums)):\n                if i != index and nums[i] == nums[i - 1]:\n                    continue\n                t.append(nums[i])\n                f(i + 1, t)\n                t.pop()\n\n        ans = []\n        nums.sort()\n        f(0, [])\n        return ans"
            }
        ],
        "source": "https://leetcode.com/problems/subsets-ii/"
    },
    "Restore IP Addresses": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def works(self, s):\n        return s == str(int(s)) and int(s) <= 255\n\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        n = len(s)\n        ans = []\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    a, b, c, d = s[:i], s[i:j], s[j:k], s[k:]\n                    if self.works(a) and self.works(b) and self.works(c) and self.works(d):\n                        ans.append(f'{a}.{b}.{c}.{d}')\n        return ans"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def valid(self, temp: str) -> bool:\n        if len(temp) > 3 or len(temp) == 0:\n            return False\n        if len(temp) > 1 and temp[0] == '0':\n            return False\n        if len(temp) and int(temp) > 255:\n            return False\n        return True\n\n    def solve(self, ans, output, ind, s, dots):\n        if dots == 3:\n            if self.valid(s[ind:]):\n                ans.append(output + s[ind:])\n            return\n        for i in range(ind, min(ind+3, len(s))):\n            if self.valid(s[ind:i+1]):\n                new_output = output + s[ind:i+1] + '.'\n                self.solve(ans, new_output, i+1, s, dots+1)\n\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        ans = []\n        self.solve(ans, \"\", 0, s, 0)\n        return ans\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def valid(segment: str) -> bool:\n            segment_length = len(segment)  # storing the length of each segment\n            if (\n                segment_length > 3\n            ):  # each segment's length should be less than or equal to 3\n                return False\n\n            # Check if the current segment is valid\n            # for either one of the following conditions:\n            # 1. Check if the current segment is less than or equal to 255.\n            # 2. Check if the length of the segment is 1. The first character of the segment\n            #    can be `0` only if the length of the segment is 1.\n            return int(segment) <= 255 if segment[0] != \"0\" else len(segment) == 1\n\n        def update_segment(\n            s: str, curr_dot: int, segments: List[str], result: List[str]\n        ):\n            segment = s[curr_dot + 1 : len(s)]\n            if valid(segment):  # if the segment is acceptable\n                segments.append(segment)  # add it to the list of segments\n                result.append(\".\".join(segments))\n                segments.pop()  # remove the top segment\n\n        def backtrack(\n            s: str, prev_dot: int, dots: int, segments: List[str], result: List[str]\n        ):\n            size = len(s)\n            # The current dot curr_dot could be placed in\n            # a range from prev_dot + 1 to prev_dot + 4.\n            # The dot couldn't be placed after the last character in the string.\n            for curr_dot in range(prev_dot + 1, min(size - 1, prev_dot + 4)):\n                segment = s[prev_dot + 1 : curr_dot + 1]\n                if valid(segment):\n                    segments.append(segment)\n\n                    # if all 3 dots are placed, add the solution to result\n                    if dots - 1 == 0:\n                        update_segment(s, curr_dot, segments, result)\n                    else:\n                        # continue to place dots\n                        backtrack(s, curr_dot, dots - 1, segments, result)\n\n                    segments.pop()  # remove the last placed segment\n\n        # creating empty lists for storing valid IP addresses,\n        # and each segment of IP\n        result, segments = [], []\n        backtrack(s, -1, 3, segments, result)\n        return result\n"
            }
        ],
        "source": "https://leetcode.com/problems/restore-ip-addresses/"
    },
    "Interleaving String": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        m, n, l = len(s1), len(s2), len(s3)\n        if m + n != l:\n            return False\n        \n        if m < n:\n            return self.isInterleave(s2, s1, s3)\n        \n        dp = [False] * (n + 1)\n        dp[0] = True\n        \n        for j in range(1, n + 1):\n            dp[j] = dp[j-1] and s2[j-1] == s3[j-1]\n        \n        for i in range(1, m + 1):\n            dp[0] = dp[0] and s1[i-1] == s3[i-1]\n            for j in range(1, n + 1):\n                dp[j] = (dp[j] and s1[i-1] == s3[i+j-1]) or (dp[j-1] and s2[j-1] == s3[i+j-1])\n        \n        return dp[n]"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        # Check if the combined length of s1 and s2 matches the length of s3\n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        # Initialize a dynamic programming array dp\n        # dp[j] will store whether s1[0:i] and s2[0:j] can form s3[0:i+j]\n        dp = [False] * (len(s2) + 1)\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    # Base case: Both s1 and s2 are empty, so s3 is also empty.\n                    # Set dp[j] to True.\n                    dp[j] = True\n                elif i == 0:\n                    # Base case: s1 is empty, so check if the previous dp[j-1]\n                    # is True and if s2[j-1] matches s3[i+j-1].\n                    dp[j] = dp[j - 1] and s2[j - 1] == s3[i + j - 1]\n                elif j == 0:\n                    # Base case: s2 is empty, so check if the current dp[j]\n                    # is True and if s1[i-1] matches s3[i+j-1].\n                    dp[j] = dp[j] and s1[i - 1] == s3[i + j - 1]\n                else:\n                    # General case: Check if either the previous dp[j] or dp[j-1]\n                    # is True and if the corresponding characters match s3[i+j-1].\n                    dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n\n        # Return the result stored in dp[len(s2)], which indicates whether\n        # s1 and s2 can form s3 by interleaving characters.\n        return dp[len(s2)]\n"
            }
        ],
        "source": "https://leetcode.com/problems/interleaving-string/"
    },
    "Triangle": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def minimumTotal(self, triangle: List[List[int]]) -> int:\n        row = len(triangle)\n        memo = triangle[row-1].copy()\n\n        for r in range(row-2, -1, -1):\n            for c in range(r+1):\n                memo[c] = min(memo[c], memo[c+1]) + triangle[r][c]\n        \n        return memo[0]"
            },
            {
                "language": "Python",
                "code": []
            }
        ],
        "source": "https://leetcode.com/problems/triangle/"
    },
    "Longest Consecutive Sequence": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        num_set = set(nums)\n        longest = 0\n\n        for n in nums:\n            if n - 1 not in num_set:\n                length = 1\n\n                while n + length in num_set:\n                    length += 1\n                \n                longest = max(longest, length)\n        \n        return longest"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        nums = set(nums)\n        table = {}\n        maxval = 0\n        for num in nums:\n            x = table.get(num - 1, 0)\n            y = table.get(num + 1, 0)\n            val = x + y + 1\n            table[num - x] = val\n            table[num + y] = val\n            maxval = max(maxval, val)\n        return maxval\n"
            }
        ],
        "source": "https://leetcode.com/problems/longest-consecutive-sequence/"
    },
    "Gas Station": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        if sum(gas) < sum(cost):\n            return -1\n                \n        curernt_gas = 0\n        start = 0\n        for i in range(len(gas)):\n            curernt_gas += gas[i] - cost[i]\n            if curernt_gas < 0:\n                curernt_gas = 0\n                start = i + 1\n\n        return start"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:\n        #gas =  [2,3,4]\n        #cost = [3,4,3]\n        #total =-1,-1,1\n        #sum of gas>= sum cost array\n        sum_cost = sum(cost)\n        sum_gas = sum(gas)\n        # Check if it is possible to complete the journey\n        if sum_cost > sum_gas:\n            return -1\n\n        current_gas = 0\n        starting_index = 0\n\n        for i in range(len(gas)):\n            current_gas += gas[i] - cost[i]\n            if current_gas < 0:\n                current_gas = 0\n                starting_index = i + 1\n        return starting_index\n        "
            }
        ],
        "source": "https://leetcode.com/problems/gas-station/"
    },
    "Word Break": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        #initialize dp array to [False] at the (len(s) + 1)\n        dp = [False] * (len(s) + 1)\n        #initialize dp[len(s)] = True for tabulation bottom up dynamic programming\n        dp[len(s)] = True\n\n        #iterate through the rest of len(s) in reverse for i\n        for i in range(len(s) - 1, -1, -1):\n            #iterate through word w in wordDict\n            for w in wordDict:\n                #Check if i + len(w) is less than or equal to len(s) for it to be inbounds and s[i : i + len(w)] == w\n                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:\n                    #Update dp[i] to dp[i + len(w)]\n                    dp[i] = dp[i + len(w)]\n                #Check if dp[i] is True\n                if dp[i]:\n                    #break as we don't need to iterate for other words\n                    break\n\n        #return the tabulated value in dp[0]\n        return dp[0]\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        dp = [True] + [False] * len(s)\n\n        for i in range(1, len(s) + 1):\n            for w in wordDict:\n                start = i - len(w)\n                if start >= 0 and dp[start] and s[start:i] == w:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"
            }
        ],
        "source": "https://leetcode.com/problems/word-break/"
    },
    "Evaluate Reverse Polish Notation": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        st = []\n\n        for c in tokens:\n            if c == \"+\":\n                st.append(st.pop() + st.pop())\n            elif c == \"-\":\n                second, first = st.pop(), st.pop()\n                st.append(first - second)\n            elif c == \"*\":\n                st.append(st.pop() * st.pop())\n            elif c == \"/\":\n                second, first = st.pop(), st.pop()\n                st.append(int(first / second))                \n            else:\n                st.append(int(c))\n        \n        return st[0]"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for token in tokens:\n            match token:\n                case '+':\n                    stack.append(stack.pop() + stack.pop())\n                    continue\n                case '*':\n                    stack.append(stack.pop() * stack.pop())\n                    continue\n                case '-':\n                    a, b = stack.pop(), stack.pop()\n                    stack.append(b - a)\n                    continue\n                case '/':\n                    a, b = stack.pop(), stack.pop()\n                    stack.append(int(b/a))\n                    continue\n                case _:\n                    stack.append(int(token))\n        return stack.pop()\n"
            }
        ],
        "source": "https://leetcode.com/problems/evaluate-reverse-polish-notation/"
    },
    "Reverse Words in a String": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        words = s.split()\n        res = []\n\n        for i in range(len(words) - 1, -1, -1):\n            res.append(words[i])\n            if i != 0:\n                res.append(\" \")\n\n        return \"\".join(res)"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def reverseWords(self, s: str) -> str:\n        # Split the string into words, filtering out extra spaces\n        words = [word for word in s.split(' ') if word]\n    \n        # Reverse the list of words\n        words.reverse()\n        \n        # Join the words with a single space and return\n        return ' '.join(words)"
            }
        ],
        "source": "https://leetcode.com/problems/reverse-words-in-a-string/"
    },
    "Find Minimum in Rotated Sorted Array": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def findMin(self, nums: List[int]) -> int:\n    \n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            mid = (left + right) // 2\n\n            if nums[mid] <= nums[right]:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return nums[left]"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # set left and right bounds\n        left, right = 0, len(nums)-1\n                \n        # left and right both converge to the minimum index;\n        # DO NOT use left <= right because that would loop forever\n        while left < right:\n            # find the middle value between the left and right bounds (their average);\n\t\t\t# can equivalently do: mid = left + (right - left) // 2,\n\t\t\t# if we are concerned left + right would cause overflow (which would occur\n\t\t\t# if we are searching a massive array using a language like Java or C that has\n\t\t\t# fixed size integer types)\n            mid = (left + right) // 2\n                        \n            # the main idea for our checks is to converge the left and right bounds on the start\n            # of the pivot, and never disqualify the index for a possible minimum value.\n\n            # in normal binary search, we have a target to match exactly,\n            # and would have a specific branch for if nums[mid] == target.\n            # we do not have a specific target here, so we just have simple if/else.\n                        \n            if nums[mid] > nums[right]:\n                # we KNOW the pivot must be to the right of the middle:\n                # if nums[mid] > nums[right], we KNOW that the\n                # pivot/minimum value must have occurred somewhere to the right\n                # of mid, which is why the values wrapped around and became smaller.\n\n                # example:  [3,4,5,6,7,8,9,1,2] \n                # in the first iteration, when we start with mid index = 4, right index = 9.\n                # if nums[mid] > nums[right], we know that at some point to the right of mid,\n                # the pivot must have occurred, which is why the values wrapped around\n                # so that nums[right] is less then nums[mid]\n\n                # we know that the number at mid is greater than at least\n                # one number to the right, so we can use mid + 1 and\n                # never consider mid again; we know there is at least\n                # one value smaller than it on the right\n                left = mid + 1\n\n            else:\n                # here, nums[mid] <= nums[right]:\n                # we KNOW the pivot must be at mid or to the left of mid:\n                # if nums[mid] <= nums[right], we KNOW that the pivot was not encountered\n                # to the right of middle, because that means the values would wrap around\n                # and become smaller (which is caught in the above if statement).\n                # this leaves the possible pivot point to be at index <= mid.\n                            \n                # example: [8,9,1,2,3,4,5,6,7]\n                # in the first iteration, when we start with mid index = 4, right index = 9.\n                # if nums[mid] <= nums[right], we know the numbers continued increasing to\n                # the right of mid, so they never reached the pivot and wrapped around.\n                # therefore, we know the pivot must be at index <= mid.\n\n                # we know that nums[mid] <= nums[right].\n                # therefore, we know it is possible for the mid index to store a smaller\n                # value than at least one other index in the list (at right), so we do\n                # not discard it by doing right = mid - 1. it still might have the minimum value.\n                right = mid\n                \n        # at this point, left and right converge to a single index (for minimum value) since\n        # our if/else forces the bounds of left/right to shrink each iteration:\n\n        # when left bound increases, it does not disqualify a value\n        # that could be smaller than something else (we know nums[mid] > nums[right],\n        # so nums[right] wins and we ignore mid and everything to the left of mid).\n\n        # when right bound decreases, it also does not disqualify a\n        # value that could be smaller than something else (we know nums[mid] <= nums[right],\n        # so nums[mid] wins and we keep it for now).\n\n        # so we shrink the left/right bounds to one value,\n        # without ever disqualifying a possible minimum\n        return nums[left]"
            }
        ],
        "source": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/"
    },
    "Find Peak Element": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = 0, len(nums) - 1\n         \n        while left < right: \n            index = (left + right)//2    \n            # peak is in the left half, excluding index\n            if nums[index] <= nums[index +1]:\n                left = index + 1\n\n            # peak is in the right half, including index     \n            else :\n                right = index \n   \n        return left\n  \n\n"
            }
        ],
        "source": "https://leetcode.com/problems/find-peak-element/"
    },
    "Maximum Gap": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def maximumGap(self, nums):\n        lo, hi, n = min(nums), max(nums), len(nums)\n        if n <= 2 or hi == lo: return hi - lo\n        B = defaultdict(list)\n        for num in nums:\n            ind = n-2 if num == hi else (num - lo)*(n-1)//(hi-lo)\n            B[ind].append(num)\n            \n        cands = [[min(B[i]), max(B[i])] for i in range(n-1) if B[i]]\n        return max(y[0]-x[1] for x,y in zip(cands, cands[1:]))"
            }
        ],
        "source": "https://leetcode.com/problems/maximum-gap/"
    },
    "Median of Two Sorted Arrays": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def findMedianSortedArrays(self, joe: List[int], poop: List[int]) -> float:\n        dog = len(joe)\n        fart = len(poop)\n\n        if (dog > fart):\n            [joe, poop, dog, fart] = [poop, joe, fart, dog]\n\n        goon = 0\n        perlok18 = dog\n        dogfart = dog + fart\n        \n        while goon <= perlok18:\n            peepee = (goon + perlok18) // 2\n            poopoo = (dogfart + 1) // 2 - peepee\n\n            gunga = joe[peepee - 1] if peepee > 0 else float('-inf')\n            ginga = float('inf') if peepee == dog else joe[peepee]\n            amiri = poop[poopoo - 1] if poopoo > 0 else float('-inf') \n            ragol = float('inf') if poopoo == fart else poop[poopoo]\n\n            if gunga <= ragol and amiri <= ginga:\n                return max(gunga, amiri) if dogfart % 2 else (max(gunga, amiri) + min(ginga, ragol)) / 2\n            elif gunga > ragol:\n                perlok18 = peepee - 1\n            else:\n                goon = peepee + 1\n\n        return 0"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def findMedianSortedArrays(self, joe: List[int], poop: List[int]) -> float:\n        dog = len(joe)\n        fart = len(poop)\n\n        if (dog > fart):\n            [joe, poop, dog, fart] = [poop, joe, fart, dog]\n\n        goon = 0\n        perlok18 = dog\n        dogfart = dog + fart\n        \n        while goon <= perlok18:\n            peepee = (goon + perlok18) // 2\n            poopoo = (dogfart + 1) // 2 - peepee\n\n            gunga = joe[peepee - 1] if peepee > 0 else float('-inf')\n            ginga = float('inf') if peepee == dog else joe[peepee]\n            amiri = poop[poopoo - 1] if poopoo > 0 else float('-inf') \n            ragol = float('inf') if poopoo == fart else poop[poopoo]\n\n            if gunga <= ragol and amiri <= ginga:\n                return max(gunga, amiri) if dogfart % 2 else (max(gunga, amiri) + min(ginga, ragol)) / 2\n            elif gunga > ragol:\n                perlok18 = peepee - 1\n            else:\n                goon = peepee + 1\n\n        return 0"
            }
        ],
        "source": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
    },
    "First Missing Positive": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        nums = [n for n in nums if n > 0]\n        nums.sort()\n\n        target = 1\n        for n in nums:\n            if n == target:\n                target += 1\n            elif n > target:\n                return target\n        \n        return target"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        # Function to swap elements in the array\n        def swap(arr, i, j):\n            arr[i], arr[j] = arr[j], arr[i]\n        \n        n = len(nums)\n        \n        # Place each positive integer i at index i-1 if possible\n        for i in range(n):\n            while 0 < nums[i] <= n and nums[i] != nums[nums[i] - 1]:\n                swap(nums, i, nums[i] - 1)\n        \n        # Find the first missing positive integer\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        \n        # If all positive integers from 1 to n are present, return n + 1\n        return n + 1\n"
            }
        ],
        "source": "https://leetcode.com/problems/first-missing-positive/"
    },
    "Permutation Sequence": {
        "solutions": [
            {
                "language": "Python",
                "code": "\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        arr = [i for i in range(1, n + 1)] \n        freq = [0] * n  \n        res = [] \n        \n        self.bpermute([], freq, k, arr, res)\n        return ''.join(map(str, res))  \n\n    def bpermute(self, temp: List[int], freq: List[int], k: int, arr: List[int], res: List[int]) -> int:\n        if len(temp) == len(arr):\n            k -= 1  \n            if k == 0:  \n                res.extend(temp) \n            return k  \n        \n        for i in range(len(arr)):\n            if not freq[i]: \n                temp.append(arr[i])\n                freq[i] = 1  \n\n                k = self.bpermute(temp, freq, k, arr, res)  # Recurse\n                if k == 0:  # If the k-th permutation is found, stop further recursion\n                    return 0\n\n                # Backtrack\n                temp.pop()\n                freq[i] = 0\n        \n        return k  # Return k to continue the search\n"
            },
            {
                "language": "Python",
                "code": "\nclass Solution:\n    def getPermutation(self, n: int, k: int) -> str:\n        arr = [i for i in range(1, n + 1)] \n        freq = [0] * n  \n        res = [] \n        \n        self.bpermute([], freq, k, arr, res)\n        return ''.join(map(str, res))  \n\n    def bpermute(self, temp: List[int], freq: List[int], k: int, arr: List[int], res: List[int]) -> int:\n        if len(temp) == len(arr):\n            k -= 1  \n            if k == 0:  \n                res.extend(temp) \n            return k  \n        \n        for i in range(len(arr)):\n            if not freq[i]: \n                temp.append(arr[i])\n                freq[i] = 1  \n\n                k = self.bpermute(temp, freq, k, arr, res)  # Recurse\n                if k == 0:  # If the k-th permutation is found, stop further recursion\n                    return 0\n\n                # Backtrack\n                temp.pop()\n                freq[i] = 0\n        \n        return k  # Return k to continue the search\n"
            }
        ],
        "source": "https://leetcode.com/problems/permutation-sequence/"
    },
    "Text Justification": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n\n        cnt, tmp = 0, []\n\n        for ind, i in enumerate(words):\n            if cnt + len(i) + (len(tmp) - 1) < maxWidth:\n                tmp.append(i)\n                cnt += len(i)\n\n                if ind == len(words) - 1:\n                    length = maxWidth - cnt\n                    seq = ''\n                    if len(tmp) == 1:\n                        seq = tmp[0] + (' ' * length)\n                    else:\n                        seq = ' '.join(tmp)\n                        seq += ' ' * (length - (len(tmp) - 1))\n\n                    res.append(seq)\n            else:\n                length = maxWidth - cnt\n                seq = ''\n                if len(tmp) == 1:\n                    seq = tmp[0] + (' ' * length)\n                else:\n                    div = length // (len(tmp) - 1)\n                    mod = length - (div * (len(tmp) - 1))\n                    # print('Length: ', length, ' Div: ', div, ' Mod: ', mod)\n                    for t in range(len(tmp) - 1):\n                        seq += tmp[t] + ' ' * div\n                        if mod > 0:\n                            seq += ' '\n                            mod -= 1\n                    seq += tmp[-1]\n\n                res.append(seq)\n\n                tmp.clear()\n                cnt = len(i)\n                tmp.append(i)\n                \n\n                if ind == len(words) - 1:\n                    res.append(i + ' ' * (maxWidth - len(i)))\n\n        return res\n                \n\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        res = []\n        \n        cur_wlist  = []\n        cur_ch_cnt = 0   # for the space consideration\n     \n        for w in words: \n            if cur_ch_cnt + len(cur_wlist) + len(w) > maxWidth:\n                for i in range(maxWidth - cur_ch_cnt):  # insert space\n                    cur_wlist[i%(len(cur_wlist) - 1 or 1)] += ' '\n               \n                res.append(''.join(cur_wlist)) # insert a this row \n                cur_wlist, cur_ch_cnt = [], 0 # prepare a new row, resetting\n                \n            cur_wlist += [w]\n            cur_ch_cnt += len(w)\n            \n        return res + [' '.join(cur_wlist).ljust(maxWidth)]"
            }
        ],
        "source": "https://leetcode.com/problems/text-justification/"
    },
    "Minimum Window Substring": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n\n\n        if s==t:\n            return s\n        l,r=0,0\n        n=len(s)\n        dicti={}\n        for i in t:\n            dicti[i]=dicti.get(i,0)+1\n        dics={}\n        mini=float('inf')\n        formed=0\n        required=len(dicti)\n        result=''\n        while r<n:\n            char = s[r]\n            if char in dicti:\n                dics[char] = dics.get(char, 0) + 1\n                if dics[char] == dicti[char]:\n                    formed += 1\n            while formed == required:\n                if r - l + 1 < mini:\n                    mini = r - l + 1\n                    result = s[l:r+1]\n                char = s[l]\n                if char in dicti:\n                    dics[char] -= 1\n                    if dics[char] < dicti[char]:\n                        formed -= 1\n                l += 1\n\n            r += 1\n\n        return result\n\n            \n            \n    \n\n\n\n        \n\n        \n        "
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if len(s) < len(t):\n            return \"\"\n        \n        char_count = defaultdict(int)\n        for ch in t:\n            char_count[ch] += 1\n        \n        target_chars_remaining = len(t)\n        min_window = (0, float(\"inf\"))\n        start_index = 0\n\n        for end_index, ch in enumerate(s):\n            if char_count[ch] > 0:\n                target_chars_remaining -= 1\n            char_count[ch] -= 1\n\n            if target_chars_remaining == 0:\n                while True:\n                    char_at_start = s[start_index]\n                    if char_count[char_at_start] == 0:\n                        break\n                    char_count[char_at_start] += 1\n                    start_index += 1\n                \n                if end_index - start_index < min_window[1] - min_window[0]:\n                    min_window = (start_index, end_index)\n                \n                char_count[s[start_index]] += 1\n                target_chars_remaining += 1\n                start_index += 1\n        \n        return \"\" if min_window[1] > len(s) else s[min_window[0]:min_window[1]+1]"
            }
        ],
        "source": "https://leetcode.com/problems/minimum-window-substring/"
    },
    "Largest Rectangle in Histogram": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def largestRectangleArea(self, heights):\n        stack = []\n        max_area = 0\n        n = len(heights)\n\n        for i in range(n + 1):\n            current_height = heights[i] if i < n else 0\n\n            while stack and heights[stack[-1]] > current_height:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            \n            stack.append(i)\n        \n        return max_area"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        stack = [-1]\n        max_area = 0\n\n        for i in range(len(heights)):\n            while stack[-1] != -1 and heights[i] <= heights[stack[-1]]:\n                height = heights[stack.pop()]\n                width = i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        \n        while stack[-1] != -1:\n            height = heights[stack.pop()]\n            width = len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        return max_area"
            }
        ],
        "source": "https://leetcode.com/problems/largest-rectangle-in-histogram/"
    },
    "Maximal Rectangle": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix:\n            return 0\n        \n        rows, cols = len(matrix), len(matrix[0])\n        heights = [0] * (cols + 1)  # Include an extra element for easier calculation\n        max_area = 0\n        \n        for row in matrix:\n            for i in range(cols):\n                heights[i] = heights[i] + 1 if row[i] == '1' else 0\n            \n            # Calculate max area using histogram method\n            n = len(heights)  # Number of bars in the histogram\n\n            for i in range(n):\n                for j in range(i, n):\n                    # Determine the minimum height between bar i and bar j\n                    min_height = min(heights[k] for k in range(i, j + 1))\n                    # Calculate the area of the rectangle\n                    area = min_height * (j - i + 1)\n                    # Update maximum area if the current rectangle's area is larger\n                    if area > max_area:\n                        max_area = area\n\n        return max_area\n        "
            },
            {
                "language": "Python",
                "code": [
                    "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        r, c=len(matrix), len(matrix[0])\n        if r==1 and c==1:\n            if matrix[0][0]=='1': return 1\n            else: return 0\n        h=[0]*(c+1)\n        maxArea=0\n\n        for i, row  in enumerate(matrix):\n            st=[-1] \n            row.append('0')\n            for j, x in enumerate(row):\n                # build h\n                if x=='1': h[j]+=1\n                else: h[j]=0\n                # mononotonic stack has at leat element -1\n                while len(st)>1 and (j==c or h[j]<h[st[-1]]):\n                    m=st[-1]\n                    st.pop()\n                    w=j-st[-1]-1\n                    area=h[m]*w\n                    maxArea=max(maxArea, area)\n                st.append(j)\n        return maxArea\n\n        "
                ]
            }
        ],
        "source": "https://leetcode.com/problems/maximal-rectangle/"
    },
    "Scramble String": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                dp[i][j][1] = (s1[i] == s2[j])\n        \n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                for j in range(n-length+1):\n                    for k in range(1, length):\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\n                            dp[i][j][length] = True\n                            break\n        \n        return dp[0][0][n]\n\n    \n        # An Upvote will be encouraging\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if s1 == s2:\n            return True\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        n = len(s1)\n        dp = [[[False] * (n+1) for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                dp[i][j][1] = (s1[i] == s2[j])\n        \n        for length in range(2, n+1):\n            for i in range(n-length+1):\n                for j in range(n-length+1):\n                    for k in range(1, length):\n                        if (dp[i][j][k] and dp[i+k][j+k][length-k]) or (dp[i][j+length-k][k] and dp[i+k][j][length-k]):\n                            dp[i][j][length] = True\n                            break\n        \n        return dp[0][0][n]\n\n    \n        # An Upvote will be encouraging\n"
            }
        ],
        "source": "https://leetcode.com/problems/scramble-string/"
    },
    "Distinct Subsequences": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        # Create a memoization dictionary to store the number of distinct subsequences\n        memory = {}\n\n        # Base cases:\n        # For each index i in s, set memory[(i, len(t))] = 1 because an empty string is a subsequence of any string, including t.\n        # For each index j in t, set memory[(len(s), j)] = 0 because an empty string cannot contain any non-empty subsequence of t.\n        for i in range(len(s) + 1):\n            memory[(i, len(t))] = 1\n        for j in range(len(t)):\n            memory[(len(s), j)] = 0\n\n        # Fill the memoization table iteratively\n        for i in range(len(s) - 1, -1, -1):\n            for j in range(len(t) - 1, -1, -1):\n                # If s[i] == t[j], we have two choices:\n                if s[i] == t[j]:\n                    # 1. Include s[i] in the subsequence: This means we count the number of distinct subsequences that end with s[i] and equal t[j:].\n                    # This is memory[(i + 1, j + 1)].\n                    # 2. Exclude s[i] from the subsequence: This means we count the number of distinct subsequences of s[i+1:] that equal t[j:].\n                    # This is memory[(i + 1, j)].\n                    # So, memory[(i, j)] = memory[(i + 1, j + 1)] + memory[(i + 1, j)].\n                    memory[(i, j)] = memory[(i + 1, j + 1)] + memory[(i + 1, j)]\n                else:\n                    # If s[i] != t[j], we cannot include s[i] in the subsequence, so memory[(i, j)] = memory[(i + 1, j)].\n                    memory[(i, j)] = memory[(i + 1, j)]\n        # Return the number of distinct subsequences of s that equal t.\n        return memory[(0, 0)]"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        # Create a memoization dictionary to store the number of distinct subsequences\n        memory = {}\n\n        # Base cases:\n        # For each index i in s, set memory[(i, len(t))] = 1 because an empty string is a subsequence of any string, including t.\n        # For each index j in t, set memory[(len(s), j)] = 0 because an empty string cannot contain any non-empty subsequence of t.\n        for i in range(len(s) + 1):\n            memory[(i, len(t))] = 1\n        for j in range(len(t)):\n            memory[(len(s), j)] = 0\n\n        # Fill the memoization table iteratively\n        for i in range(len(s) - 1, -1, -1):\n            for j in range(len(t) - 1, -1, -1):\n                # If s[i] == t[j], we have two choices:\n                if s[i] == t[j]:\n                    # 1. Include s[i] in the subsequence: This means we count the number of distinct subsequences that end with s[i] and equal t[j:].\n                    # This is memory[(i + 1, j + 1)].\n                    # 2. Exclude s[i] from the subsequence: This means we count the number of distinct subsequences of s[i+1:] that equal t[j:].\n                    # This is memory[(i + 1, j)].\n                    # So, memory[(i, j)] = memory[(i + 1, j + 1)] + memory[(i + 1, j)].\n                    memory[(i, j)] = memory[(i + 1, j + 1)] + memory[(i + 1, j)]\n                else:\n                    # If s[i] != t[j], we cannot include s[i] in the subsequence, so memory[(i, j)] = memory[(i + 1, j)].\n                    memory[(i, j)] = memory[(i + 1, j)]\n        # Return the number of distinct subsequences of s that equal t.\n        return memory[(0, 0)]"
            }
        ],
        "source": "https://leetcode.com/problems/distinct-subsequences/"
    },
    "Best Time to Buy and Sell Stock III": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def solve(self, index, buy, cnt, n, prices):\n        if index == n or cnt == 0:\n            return 0\n        profit = 0\n        if buy:\n            pick = -prices[index] + self.solve(index + 1, False, cnt, n, prices)\n            notPick = self.solve(index + 1, True, cnt, n, prices)\n            profit = max(pick, notPick)\n        else:\n            pick = prices[index] + self.solve(index + 1, True, cnt - 1, n, prices)\n            notPick = self.solve(index + 1, False, cnt, n, prices)\n            profit = max(pick, notPick)\n        return profit\n\n    def maxProfit(self, prices):\n        n = len(prices)\n        return self.solve(0, True, 2, n, prices)\n"
            },
            {
                "language": "Python",
                "code": [
                    "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        # The variables are long for better understanding\n        \n        # Initialize variables to track minimum prices and maximum profits\n        min_price_after_first_buy = float('inf')\n        max_profit_after_first_sell = 0\n        min_price_after_second_buy = float('inf')\n        max_profit_after_second_sell = 0\n        \n        for price in prices:\n            # Update the minimum price for the first buy\n            min_price_after_first_buy = min(min_price_after_first_buy, price)\n            \n            # Calculate profit after the first sell\n            max_profit_after_first_sell = max(max_profit_after_first_sell, price - min_price_after_first_buy)\n            \n            # Update the minimum price for the second buy\n            min_price_after_second_buy = min(min_price_after_second_buy, price - max_profit_after_first_sell)\n            \n            # Calculate profit after the second sell\n            max_profit_after_second_sell = max(max_profit_after_second_sell, price - min_price_after_second_buy)\n        \n        return max_profit_after_second_sell\n"
                ]
            }
        ],
        "source": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/"
    },
    "Word Ladder": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list[str]) -> int:\n        # Create a set for fast lookup of words\n        word_set = set(wordList)\n\n        # If the endWord is not in the wordList, we cannot form a transformation\n        if endWord not in word_set:\n            return 0\n\n        # BFS queue: stores (current word, transformation steps)\n        queue = deque([(beginWord, 1)])\n        word_set.discard(beginWord)  # Remove the starting word to avoid revisiting it\n\n        while queue:\n            word, steps = queue.popleft()\n\n            # Try all possible transformations\n            for i in range(len(word)):\n                original_char = word[i]  # Save the original character\n\n                # Replace with every possible character from 'a' to 'z'\n                for ch in \"abcdefghijklmnopqrstuvwxyz\":\n                    word = word[:i] + ch + word[i + 1 :]\n\n                    # Check if the transformed word is the endWord\n                    if word == endWord:\n                        return steps + 1\n\n                    # If the transformed word exists in the set, process it\n                    if word in word_set:\n                        word_set.remove(word)  # Remove the word from the set\n                        queue.append((word, steps + 1))\n\n                word = (\n                    word[:i] + original_char + word[i + 1 :]\n                )  # Restore the original character\n\n        return 0  # If no transformation sequence is found"
            },
            {
                "language": "Python",
                "code": "from collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list) -> int:\n        wordSet = set(wordList)  # Convert list to set for fast lookup\n        if endWord not in wordSet:\n            return 0\n\n        queue = deque([(beginWord, 1)])  # BFS queue storing (word, steps)\n\n        while queue:\n            word, steps = queue.popleft()\n\n            if word == endWord:\n                return steps\n\n            for i in range(len(word)):\n                original = word[i]\n                for ch in range(26):  # Check all possible single character changes\n                    transformed = word[:i] + chr(ord('a') + ch) + word[i + 1:]\n                    if transformed in wordSet:\n                        wordSet.remove(transformed)  # Avoid revisiting\n                        queue.append((transformed, steps + 1))\n        \n        return 0  # If no valid transformation is found\n"
            }
        ],
        "source": "https://leetcode.com/problems/word-ladder/"
    },
    "Candy": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        total_candies = n\n        i = 1\n\n        while i < n:\n            if ratings[i] == ratings[i - 1]:\n                i += 1\n                continue\n\n            current_peak = 0\n            while i < n and ratings[i] > ratings[i - 1]:\n                current_peak += 1\n                total_candies += current_peak\n                i += 1\n            \n            if i == n:\n                return total_candies\n\n            current_valley = 0\n            while i < n and ratings[i] < ratings[i - 1]:\n                current_valley += 1\n                total_candies += current_valley\n                i += 1\n\n            total_candies -= min(current_peak, current_valley)\n\n        return total_candies"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        if len(ratings) == 1:\n            return 1\n        if len(ratings) == 2:\n            if ratings[0] == ratings[1]:\n                return 2\n            else:\n                return 3\n        \n        choc = [1] * len(ratings)\n        \n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                choc[i] = choc[i - 1] + 1\n        \n        for i in range(len(ratings) - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                choc[i] = max(choc[i], choc[i + 1] + 1)\n\n        return sum(choc)\n"
            }
        ],
        "source": "https://leetcode.com/problems/candy/"
    },
    "Word Break II": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    \n"
            },
            {
                "language": "Python",
                "code": "def fun(s,dc,memo):\n    if(s in memo):\n        return memo[s]\n    ans=[]\n    if(dc[s]==1):\n        ans=[s]\n    for i in range(1,len(s)):\n        if(dc[s[:i]]==1):\n            a=fun(s[i:],dc,memo)\n            for x in a:\n                ans.append(s[:i]+\" \"+x)\n    memo[s]=ans\n    return ans\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        dc=defaultdict(lambda:0)\n        for a in wordDict:\n            dc[a]=1\n        return(fun(s,dc,{}))"
            }
        ],
        "source": "https://leetcode.com/problems/word-break-ii/"
    },
    "Find Minimum in Rotated Sorted Array II": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n\t\tN=len(nums)\n        start=0\n        end=N-1\n        while start<=end:\n            mid=(start+end)//2\n            if target==nums[mid]:\n                return mid\n            # first half order\n            if nums[mid]>=nums[start]:\n                if nums[mid]>target>=nums[start]:\n                    end=mid-1\n                else:\n                    start=mid+1\n            # second half order\n            else:\n                if nums[mid]<target<=nums[end]:\n                    start=mid+1\n                else:\n                    end=mid-1\n        return -1"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n\t\tN=len(nums)\n        start=0\n        end=N-1\n        while start<=end:\n            mid=(start+end)//2\n            if target==nums[mid]:\n                return mid\n            # first half order\n            if nums[mid]>=nums[start]:\n                if nums[mid]>target>=nums[start]:\n                    end=mid-1\n                else:\n                    start=mid+1\n            # second half order\n            else:\n                if nums[mid]<target<=nums[end]:\n                    start=mid+1\n                else:\n                    end=mid-1\n        return -1"
            }
        ],
        "source": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/"
    },
    "Best Time to Buy and Sell Stock IV": {
        "solutions": [
            {
                "language": "Python",
                "code": "class DoubleLinkListNode:\n    def __init__(self, ind, pre = None, next = None):\n        self.ind = ind\n        self.pre = pre if pre else self\n        self.next = next if next else self\n\nclass Solution:\n    def MinMaxList(self, arr: List[int]) -> List[int]:\n        n = len(arr)\n        if n == 0:\n            return []\n        sign = -1\n        res = [9999]\n        for num in arr:\n            if num * sign > res[-1] * sign:\n                res[-1] = num\n            else:\n                res.append(num)\n                sign *= -1\n        if len(res) & 1:\n            res.pop()\n        return res\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        newP = self.MinMaxList(prices)\n        n = len(newP)\n        m = n // 2\n        res = 0\n        for i in range(m):\n            res += newP[i*2+1] - newP[i*2]\n        if m <= k:\n            return res\n        head, tail = DoubleLinkListNode(-1), DoubleLinkListNode(-1)\n        NodeList = [DoubleLinkListNode(0, head)]\n        for i in range(1, n):\n            NodeList.append(DoubleLinkListNode(i, NodeList[-1]))\n            NodeList[i-1].next = NodeList[i]\n        NodeList[n-1].next = tail\n        head.next, tail.pre = NodeList[0], NodeList[n-1]\n        heap = []\n        for i in range(n-1):\n            if i&1:\n                heappush(heap, [newP[i] - newP[i+1], i, i+1, 0])\n            else:\n                heappush(heap, [newP[i+1] - newP[i], i, i+1, 1])\n        while m > k:\n            loss, i, j, t = heappop(heap)\n            if NodeList[i] == None or NodeList[j] == None: continue\n            m -= 1\n            res -= loss\n            nodei, nodej = NodeList[i], NodeList[j]\n            nodel, noder = nodei.pre, nodej.next\n            l, r = nodel.ind, noder.ind\n            valL, valR = newP[l], newP[r]\n            noder.pre, nodel.next = nodel, noder\n            NodeList[i], NodeList[j] = None, None\n            if t == 0:\n                heappush(heap, [valR - valL, l, r, 1])\n            elif l != -1 and r != -1:\n                heappush(heap, [valL - valR, l, r, 0])\n        return res"
            },
            {
                "language": "Python",
                "code": [
                    "class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        # no transaction, no profit\n        if k == 0: return 0\n        # dp[k][0] = min cost you need to spend at most k transactions\n        # dp[k][1] = max profit you can achieve at most k transactions\n        dp = [[1000, 0] for _ in range(k + 1)]\n        for price in prices:\n            for i in range(1, k + 1):\n                # price - dp[i - 1][1] is how much you need to spend\n                # i.e use the profit you earned from previous transaction to buy the stock\n                # we want to minimize it\n                dp[i][0] = min(dp[i][0], price - dp[i - 1][1])\n                # price - dp[i][0] is how much you can achieve from previous min cost\n                # we want to maximize it\n                dp[i][1] = max(dp[i][1], price - dp[i][0])\n        # return max profit at most k transactions\n\t\t# or you can write `return dp[-1][1]`\n        return dp[k][1]"
                ]
            }
        ],
        "source": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/"
    },
    "The Skyline Problem": {
        "solutions": [
            {
                "language": "Python",
                "code": "from sortedcontainers import SortedList\nclass Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        if len(buildings) == 0: \n            return []\n        \n        buildings.sort(key=lambda v: v[2])\n        pos, height = [0], [0]\n        for left, right, h in buildings: \n            i = bisect_left(pos, left)\n            j = bisect_right(pos, right)\n            height[i:j] = [h, height[j-1]]\n            pos[i:j] = [left, right]\n        print(height, pos)\n        res = []\n        prev = 0\n        for v, h in zip(pos, height): \n            if h != prev:\n                res.append([v,h]) \n                prev = h\n                \n        return res"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:\n        bs = []\n        for l, r, h in buildings:\n            bs.append([l, h, 1])\n            bs.append([r, h, 0])\n        bs.sort(key=lambda b: (b[0], -b[1] if b[2] == 1 else b[1], -b[2]))\n\n        res = []\n        prev_height = 0 \n        prev_x = -1\n        active_buildings = []\n\n        for x, h, is_left in bs:\n            if is_left:\n                bisect.insort(active_buildings, h)\n            else:\n                active_buildings.remove(h)\n\n            skyline_height = active_buildings[-1] if active_buildings else 0\n            if prev_height != skyline_height and prev_x != x:\n                res.append([x, skyline_height])\n                prev_height = skyline_height\n                prev_x = x\n\n        return res"
            }
        ],
        "source": "https://leetcode.com/problems/the-skyline-problem/"
    },
    "Basic Calculator": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    num = 0\n    sign = 1\n    stack = [sign]  # stack[-1]: current env's sign\n\n    for c in s:\n      if c.isdigit():\n        num = num * 10 + (ord(c) - ord('0'))\n      elif c == '(':\n        stack.append(sign)\n      elif c == ')':\n        stack.pop()\n      elif c == '+' or c == '-':\n        ans += sign * num\n        sign = (1 if c == '+' else -1) * stack[-1]\n        num = 0\n\n    return ans + sign * num\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def calculate(self, s):\n        def update(op, v):\n            if op == \"+\": stack.append(v)\n            if op == \"-\": stack.append(-v)\n            if op == \"*\": stack.append(stack.pop() * v)           #for BC II and BC III\n            if op == \"/\": stack.append(int(stack.pop() / v))      #for BC II and BC III\n    \n        it, num, stack, sign = 0, 0, [], \"+\"\n        \n        while it < len(s):\n            if s[it].isdigit():\n                num = num * 10 + int(s[it])\n            elif s[it] in \"+-*/\":\n                update(sign, num)\n                num, sign = 0, s[it]\n            elif s[it] == \"(\":                                        # For BC I and BC III\n                num, j = self.calculate(s[it + 1:])\n                it = it + j\n            elif s[it] == \")\":                                        # For BC I and BC III\n                update(sign, num)\n                return sum(stack), it + 1\n            it += 1\n        update(sign, num)\n        return sum(stack)"
            }
        ],
        "source": "https://leetcode.com/problems/basic-calculator/"
    },
    "Sliding Window Maximum": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def maxSlidingWindow(self, nums, k):\n        result = []\n        window = deque()\n\n        for i, num in enumerate(nums):\n            while window and window[0] < i - k + 1:\n                window.popleft()\n\n            while window and nums[window[-1]] < num:\n                window.pop()\n\n            window.append(i)\n\n            if i >= k - 1:\n                result.append(nums[window[0]])\n\n        return result\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        q = deque()\n\n        for idx, num in enumerate(nums):\n            while q and q[-1] < num:\n                q.pop()\n            q.append(num)\n\n            if idx >= k and nums[idx - k] == q[0]:\n                q.popleft()\n            \n            if idx >= k - 1:\n                res.append(q[0])\n        \n        return res"
            }
        ],
        "source": "https://leetcode.com/problems/sliding-window-maximum/"
    },
    "Expression Add Operators": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n  def addOperators(self, num: str, target: int) -> List[str]:\n    ans = [] # list to store all possible expressions that evaluate to the target\n\n    # DFS function to generate all possible expressions\n    # start: current index in num\n    # prev: previous operand value\n    # eval: current evaluated value\n    # path: list to store current expression\n    def dfs(start: int, prev: int, eval: int, path: List[str]) -> None:\n      # base case: reached end of num\n      if start == len(num):\n        # check if current evaluation equals target\n        if eval == target:\n          # add current expression to the answer list\n          ans.append(''.join(path))\n        return\n\n      # iterate over all possible operands from current index\n      for i in range(start, len(num)):\n        # special case: ignore operands starting with 0, except 0 itself\n        if i > start and num[start] == '0':\n          return\n        s = num[start:i + 1]\n        curr = int(s)\n        # special case: first operand, simply add it to the path and evaluate\n        if start == 0:\n          path.append(s)\n          dfs(i + 1, curr, curr, path)\n          path.pop()\n        # general case: iterate over all possible operators and operands\n        else:\n          for op in ['+', '-', '*']:\n            path.append(op + s)\n            # addition: add current operand to evaluated value\n            if op == '+':\n              dfs(i + 1, curr, eval + curr, path)\n            # subtraction: subtract current operand from evaluated value\n            elif op == '-':\n              dfs(i + 1, -curr, eval - curr, path)\n            # multiplication: multiply current operand with previous operand and update evaluated value\n            else:\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\n            path.pop()\n\n    # start DFS with initial parameters\n    dfs(0, 0, 0, [])\n    return ans\n"
            },
            {
                "language": "Python",
                "code": "class Solution:\n  def addOperators(self, num: str, target: int) -> List[str]:\n    ans = [] # list to store all possible expressions that evaluate to the target\n\n    # DFS function to generate all possible expressions\n    # start: current index in num\n    # prev: previous operand value\n    # eval: current evaluated value\n    # path: list to store current expression\n    def dfs(start: int, prev: int, eval: int, path: List[str]) -> None:\n      # base case: reached end of num\n      if start == len(num):\n        # check if current evaluation equals target\n        if eval == target:\n          # add current expression to the answer list\n          ans.append(''.join(path))\n        return\n\n      # iterate over all possible operands from current index\n      for i in range(start, len(num)):\n        # special case: ignore operands starting with 0, except 0 itself\n        if i > start and num[start] == '0':\n          return\n        s = num[start:i + 1]\n        curr = int(s)\n        # special case: first operand, simply add it to the path and evaluate\n        if start == 0:\n          path.append(s)\n          dfs(i + 1, curr, curr, path)\n          path.pop()\n        # general case: iterate over all possible operators and operands\n        else:\n          for op in ['+', '-', '*']:\n            path.append(op + s)\n            # addition: add current operand to evaluated value\n            if op == '+':\n              dfs(i + 1, curr, eval + curr, path)\n            # subtraction: subtract current operand from evaluated value\n            elif op == '-':\n              dfs(i + 1, -curr, eval - curr, path)\n            # multiplication: multiply current operand with previous operand and update evaluated value\n            else:\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\n            path.pop()\n\n    # start DFS with initial parameters\n    dfs(0, 0, 0, [])\n    return ans\n"
            }
        ],
        "source": "https://leetcode.com/problems/expression-add-operators/"
    },
    "Remove Invalid Parentheses": {
        "solutions": [
            {
                "language": "Python",
                "code": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # define when a combination of parenthesis is still valid\n        def valid(candidate):\n            counter = 0\n            for char in candidate:\n                if char == \"(\": counter += 1\n                elif char == \")\": counter -= 1\n                if counter < 0: return False\n            # balanced?\n            return counter == 0\n        # the actual BFS, we return the minimum of removals, so we stop as soon as we have something\n        res, frontier = set() , set([s])\n        while not res:\n            _next = set()\n            for candidate in frontier:\n                if valid(candidate): res.add(candidate); continue\n                # generate more candidates based on this candidate\n                for i, letter in enumerate(candidate):\n                    # skip trash\n                    if letter not in \"()\": continue\n                    _next.add(candidate[:i] + candidate[i+1:])\n            frontier = _next\n        return res"
            },
            {
                "language": "Python",
                "code": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        # define when a combination of parenthesis is still valid\n        def valid(candidate):\n            counter = 0\n            for char in candidate:\n                if char == \"(\": counter += 1\n                elif char == \")\": counter -= 1\n                if counter < 0: return False\n            # balanced?\n            return counter == 0\n        # the actual BFS, we return the minimum of removals, so we stop as soon as we have something\n        res, frontier = set() , set([s])\n        while not res:\n            _next = set()\n            for candidate in frontier:\n                if valid(candidate): res.add(candidate); continue\n                # generate more candidates based on this candidate\n                for i, letter in enumerate(candidate):\n                    # skip trash\n                    if letter not in \"()\": continue\n                    _next.add(candidate[:i] + candidate[i+1:])\n            frontier = _next\n        return res"
            }
        ],
        "source": "https://leetcode.com/problems/remove-invalid-parentheses/"
    }
}